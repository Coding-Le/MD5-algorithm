# MD5-algorithm
This is a MD5 algorithm.

The MD5 message-digest algorithm is used to in a wide variety of cryptographic applications, and is also commonly used to verify data integrity. No history, no future, if we want to analyze the algorithm deeper, we should know how this concept is generated.
    When analytic work indicated that MD5's predecessor MD4 was likely to be insecure, Rivest designed MD5 in 1991 as a secure replacement.The 128-bit (16-byte) MD4 hashes (also termed message digests) are typically represented as 32-digit hexadecimal numbers.Since the MD4 collision example is not different to generate, we need to find some new strategy to replace it.We should not only use the hash function but we need to operate on the raw data first.
    The MD5 used such thought to improve the security from MD4, MD5 processes a variable-length message into a fixed-length output of 128 bits. In details, the input message is broken up into chunks of 512-bit blocks, 16 groups of 32 bits.Thus the message must be padded so that its length can be divisible by 512. The padding works as follows: first a single bit, 1, is appended to the end of the message. This is followed by as many zeros as are required to bring the length of the message up to 64 bits fewer than a multiple of 512. The remaining bits are filled up with 64 bits representing the length of the original message, modulo 2^64.
    The main MD5 algorithm operates on a 128-bit state, divided into four 32-bit words, denoted A, B, C, and D. These are initialized to certain fixed constants(A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210). The main algorithm then uses each 512-bit message block in turn to modify the state. Before each processing, we let a = A, b = B, c = C, d = D, The processing of a message block consists of four similar stages, termed rounds; each round is composed of 16 similar operations based on a non-linear function F, modular addition, and left rotation. There are four possible functions F as following:
        FF(a ,b ,c ,d ,Mj ,s ,ti )  :a = b + ( (a + (b&c)|((~b)&d) + Mj + ti) << s)
        GG(a ,b ,c ,d ,Mj ,s ,ti )  :a = b + ( (a + (b&d)|(c&(~d)) + Mj + ti) << s)
        HH(a ,b ,c ,d ,Mj ,s ,ti)  :a = b + ( (a + b^c^d + Mj + ti) << s)
        II(a ,b ,c ,d ,Mj ,s ,ti)    :a = b + ( (a + c^(b|(~d)) + Mj + ti) << s)
       Mj denotes the jth group  ti = 4294967296*abs(sin(i))  (i=1~64)
    A different one is used in each round:denote the XOR, AND, OR and NOT operations respectively. And each round used one of the four functions 16 times, thus the total processing process consists 16*4 = 64 steps. These four functions based on the fact that if X、Y、Z are all independent from others, then the results of the functions are also independent. After doing this, we add the result a,b,c,d to A,B,C,D, making A = A+a, B = B+b, C = C+c, D = D+d.(Before next processing, we need to let a = A, b = B, c = C, d = D). And we adapt this processing to every message block.
    After every block has been processed, we output the cascading of A, B, C, D as a 128 bits total output, and this is the output for a random input string using MD5 algorithm.
